/* eslint-disable no-shadow */
import {join, resolve, sep} from 'path';
import {readFileSync} from 'fs';

import {complement, isMdExtension, isHidden, allPass, compose, prop, getDirs, getFiles} from './common';

import {YfmToc, IncluderFnParams, IncluderFnOutput} from '../../../models';

const isMdVisible = allPass([isMdExtension, complement(isHidden)]);

function generateContent(params: IncluderFnParams): IncluderFnOutput {
    const {
        include: {path, mode},
        root,
    } = params;

    if (mode !== 'link') {
        throw new Error('include with the includer supports only link mode, set mode: link');
    }

    return generateContentRec(join(root, path));
}

function generateContentRec(depth: string): IncluderFnOutput {
    const containsWatermark = (str: string) => /^This file was generated by \[SourceDocs\]/gmu.test(str);
    const processContent = (content: string) =>
        content.split('\n').filter(complement(containsWatermark)).join('\n');

    const fileItem = ({name}: {name: string}) => {
        const path = join(depth, name);
        const content = readFileSync(resolve(path), {encoding: 'utf8'});

        return ({
            path,
            content: processContent(content),
        });
    };

    const dirItems = getDirs(resolve(depth)).map(({name}) => name);
    const fileItems = getFiles(resolve(depth)).filter(compose(isMdVisible, prop('name'))).map(fileItem);

    const recurse = dirItems.map((name) => generateContentRec(join(depth, name)));

    return [...fileItems, ...recurse.flat(1)];
}

function generateTocs(params: IncluderFnParams): IncluderFnOutput {
    const {
        include: {path, mode},
        name,
        root,
    } = params;

    if (mode !== 'link') {
        throw new Error('include with the includer supports only link mode, set mode: link');
    }

    return generateTocsRec(join(root, path), name);
}

function generateTocsRec(depth: string, name: string): IncluderFnOutput {
    const dirItem = ({name}: {name: string}) => ({
        name,
        include: {
            path: name + sep + 'toc.yaml',
            mode: 'link',
        },
    });
    const fileItem = ({name}: {name: string}) => ({
        name: name.replace(/.md$/gmu, ''),
        href: name,
    });

    const dirItems = getDirs(resolve(depth)).map(dirItem);
    const fileItems = getFiles(resolve(depth)).filter(compose(isMdVisible, prop('name'))).map(fileItem);

    const toc = {
        name,
        href: 'index.yaml',
        items: [...dirItems, ...fileItems] as YfmToc[],
    };

    const recurse = dirItems.map(({name}) => generateTocsRec(join(depth, name), name));

    return [{content: toc, path: join(depth, 'toc.yaml')}, ...recurse.flat(1)];
}

function generateLeadingPages(
    params: IncluderFnParams,
): IncluderFnOutput {
    const {
        include: {path, mode},
        name,
        root,
    } = params;

    if (mode !== 'link') {
        throw new Error('include with the includer supports only link mode, set mode: link');
    }

    return generateLeadingPagesRec(join(root, path), name);
}

function generateLeadingPagesRec(
    depth: string,
    name: string,
): IncluderFnOutput {
    const dirLink = ({name}: {name: string}) => ({
        title: name,
        href: name + sep,
    });
    const fileLink = ({name}: {name: string}) => ({
        title: name.replace(/.md$/gmu, ''),
        href: name,
    });

    const dirLinks = getDirs(resolve(depth)).map(dirLink);
    const fileLinks = getFiles(resolve(depth)).filter(compose(isMdVisible, prop('name'))).map(fileLink);

    const index = {
        title: name,
        links: [...dirLinks, ...fileLinks],
    };

    const recurse = dirLinks.map(({title}) => generateTocsRec(join(depth, title), title));

    return [{content: index, path: join(depth, 'index.yaml')}, ...recurse.flat(1)];
}

const name = 'sourcedocs';

export {name, generateTocs, generateLeadingPages, generateContent};
